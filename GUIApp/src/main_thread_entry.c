/* Main Thread entry function */
#include "main_thread.h"
#include "bsp_api.h"
#include "gx_api.h"
#include "gui/guiapp_specifications.h"
#include "gui/guiapp_resources.h"
#include "network_info.h"
#include "hmi_state.h"
#include "led_control/led.h"
#include <string.h>
#include <stdio.h>

#if defined(BSP_BOARD_S7G2_SK)||defined(BSP_BOARD_S5D9_PK)
#include "hardware/lcd.h"
#endif


/***********************************************************************************************************************
    Private function prototypes
 ***********************************************************************************************************************/

void main_thread_entry(void);

#if defined(BSP_BOARD_S7G2_SK)||defined(BSP_BOARD_S5D9_PK)
void g_lcd_spi_callback(spi_callback_args_t * p_args);
#endif

/***********************************************************************************************************************
    Private global variables
 ***********************************************************************************************************************/
static GX_EVENT g_gx_event;

GX_WINDOW_ROOT * p_window_root;
extern GX_CONST GX_STUDIO_WIDGET *guiapp_widget_table[];

/* HMI state (visible from usb_thread) */
volatile hmi_state_t g_hmi_state = HMI_WAIT_USB;

extern FX_MEDIA                            * g_usb_media;

/* window1 control block generated by GUIX Studio (see guiapp_specifications.h) */
extern WINDOW1_CONTROL_BLOCK window1;
/* buffer to format HTTP/IP text */
static char g_http_msg[128];
static char g_usbu_msg[128];

static void ip_to_string(ULONG ip, char *buf, UINT buf_size)
{
    UINT b1 = (ip >> 24) & 0xFF;
    UINT b2 = (ip >> 16) & 0xFF;
    UINT b3 = (ip >> 8)  & 0xFF;
    UINT b4 =  ip        & 0xFF;

    snprintf(buf, buf_size, "%u.%u.%u.%u", b1, b2, b3, b4);
}

static UINT usb_used_total_bytes_get(ULONG64 *p_used, ULONG64 *p_total)
{
    FX_MEDIA *m = g_usb_media;

    ULONG64 total =
        (ULONG64)m->fx_media_total_clusters *
        (ULONG64)m->fx_media_sectors_per_cluster *
        (ULONG64)m->fx_media_bytes_per_sector;

    ULONG64 freeb =
        (ULONG64)m->fx_media_available_clusters *
        (ULONG64)m->fx_media_sectors_per_cluster *
        (ULONG64)m->fx_media_bytes_per_sector;

    if (total == 0)
    {
        *p_used = 0;
        *p_total = 0;
        return FX_SUCCESS;
    }

    if (freeb > total) freeb = total;

    *p_total = total;
    *p_used  = total - freeb;
    return FX_SUCCESS;
}

static void usb_usage_to_string(char *out, size_t out_sz, ULONG64 used_bytes, ULONG64 total_bytes)
{
    ULONG64 used_mb  = (used_bytes  + 500000ULL)     / 1000000ULL;      /* rounded */
    ULONG64 total_g  = (total_bytes + 500000000ULL)  / 1000000000ULL;   /* rounded */

    /* Example: "123 MB / 16 G" */
    snprintf(out, out_sz, "%llu MB / %llu G",
             (unsigned long long)used_mb,
             (unsigned long long)total_g);
}

/* Updates the USB message prompt text according to the current HMI state. */
void hmi_screen_update(void)
{
    UINT status = GX_SUCCESS;
    GX_STRING message1, message2;
    GX_PROMPT               *p_message_box1  = &window1.window1_c02;
    GX_PROMPT               *p_message_box2  = &window1.window1_memory_size;
    GX_RADIAL_PROGRESS_BAR  *p_usb_donut     = &window1.window1_memory_radial_pbar;

    /* Default: hide donut unless HTTP is running */
    gx_widget_hide((GX_WIDGET *)p_usb_donut);

    static int last_state = -1;
    static UINT last_used_pct = 999;

    switch (g_hmi_state)
    {
        case HMI_WAIT_USB:
            hmi_set_status_led(LED_OFF, LED_OFF, LED_ON);

            message1.gx_string_ptr      = "Plug USB please";
            message1.gx_string_length   = strlen("Plug USB please");

            message2.gx_string_ptr    = " ";
            message2.gx_string_length = strlen(" ");
            break;

        case HMI_USB_MOUNTING:
            hmi_set_status_led(LED_OFF, LED_ON, LED_OFF);

            message1.gx_string_ptr      = "USB detected, mounting...";
            message1.gx_string_length   = strlen("USB detected, mounting...");

            message2.gx_string_ptr    = " ";
            message2.gx_string_length = strlen(" ");
            break;

        case HMI_USB_READY:
            hmi_set_status_led(LED_OFF, LED_ON, LED_OFF);

            message1.gx_string_ptr      = "USB ready.";
            message1.gx_string_length   = strlen("USB ready.");

            message2.gx_string_ptr    = " ";
            message2.gx_string_length = strlen(" ");
            break;

        case HMI_HTTP_RUNNING:
        {
            hmi_set_status_led(LED_ON, LED_OFF, LED_OFF);

            char ip_str[32] = "0.0.0.0";
            if (g_ip_info_valid)
            {
                ip_to_string(g_ipv4_address, ip_str, sizeof(ip_str));
            }

            /* USB usage -> donut */
            ULONG64 used_b = 0, total_b = 0;
            char usb_str[32];
            (void) usb_used_total_bytes_get(&used_b, &total_b);
            usb_usage_to_string(usb_str, sizeof(usb_str), used_b, total_b);
            UINT used_pct = (total_b ? (UINT)((used_b * 100ULL) / total_b) : 0);

            /* Map 0..100% -> 0..-360 degrees (clockwise fill). :contentReference[oaicite:3]{index=3} */
            GX_VALUE angle = (GX_VALUE)(-((INT)used_pct * -360) / 100);

            gx_widget_show((GX_WIDGET *)p_usb_donut);
            gx_radial_progress_bar_value_set(p_usb_donut, angle);
            gx_system_dirty_mark((GX_WIDGET *)p_usb_donut);

            /* Message */
            snprintf(g_http_msg, sizeof(g_http_msg), "IP: %s", ip_str);
            /* \nUSB used: %u%%, used_pct */
            message1.gx_string_ptr    = g_http_msg;
            message1.gx_string_length = strlen(g_http_msg);

            snprintf(g_usbu_msg, sizeof(g_usbu_msg),
                     "%s", usb_str);
            message2.gx_string_ptr    = g_usbu_msg;
            message2.gx_string_length = strlen(g_usbu_msg);
        }
            break;

        case HMI_ERROR_ERASING_WEBAPP_FILES:
            hmi_set_status_led(LED_ON, LED_OFF, LED_ON);

            message1.gx_string_ptr      = "Couldn't erase WebApp files";
            message1.gx_string_length   = strlen("Couldn't erase WebApp files");

            message2.gx_string_ptr      = " ";
            message2.gx_string_length   = strlen(" ");
            break;

        default:
            break;
    }

    if (g_hmi_state != last_state)
    {
        /* show/hide only on transitions */
        if (g_hmi_state == HMI_HTTP_RUNNING)
            gx_widget_show((GX_WIDGET*)p_usb_donut);
        else
            gx_widget_hide((GX_WIDGET*)p_usb_donut);

        last_state = g_hmi_state;
    }

    /* update donut only if value changed */
    if (g_hmi_state == HMI_HTTP_RUNNING)
    {
        ULONG64 used_b = 0, total_b = 0;
        (void) usb_used_total_bytes_get(&used_b, &total_b);
        UINT used_pct = (total_b ? (UINT)((used_b * 100ULL) / total_b) : 0);

        if (used_pct != last_used_pct)
        {
            GX_VALUE angle = (GX_VALUE)(-((INT)used_pct * 360) / 100);
            gx_radial_progress_bar_value_set(p_usb_donut, angle);
            gx_system_dirty_mark((GX_WIDGET*)p_usb_donut);
            last_used_pct = used_pct;
        }
    }

    if (status == GX_SUCCESS)
    {
        gx_prompt_text_set_ext(p_message_box1, &message1);
        gx_prompt_text_set_ext(p_message_box2, &message2);
        gx_system_dirty_mark((GX_WIDGET *)p_message_box1);
        gx_system_dirty_mark((GX_WIDGET *)p_message_box2);
        //gx_system_canvas_refresh();
    }
}



/*******************************************************************************************************************//**
    @brief  Primary logic for handling events generated by the various sub-systems.
 ***********************************************************************************************************************/
void main_thread_entry(void) {
	ssp_err_t        err;
	UINT      status = TX_SUCCESS;

    /* Initializes GUIX. */
    status = gx_system_initialize();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

    /* Initializes GUIX drivers. */
    err = g_sf_el_gx.p_api->open (g_sf_el_gx.p_ctrl, g_sf_el_gx.p_cfg);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    gx_studio_display_configure ( DISPLAY_1,
                                  g_sf_el_gx.p_api->setup,
                                  LANGUAGE_ENGLISH,
                                  DISPLAY_1_THEME_1,
                                  &p_window_root );

    err = g_sf_el_gx.p_api->canvasInit(g_sf_el_gx.p_ctrl, p_window_root);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    // Create the widgets we have defined with the GUIX data structures and resources.
    GX_CONST GX_STUDIO_WIDGET ** pp_studio_widget = &guiapp_widget_table[0];

    while (GX_NULL != *pp_studio_widget)
    {
        if (0 == strcmp("window1", (char*)(*pp_studio_widget)->widget_name))
        {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name,
                                          (GX_WIDGET *)p_window_root,
                                          GX_NULL);
        }
        else
        {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name,
                                          GX_NULL,
                                          GX_NULL);
        }
        pp_studio_widget++;
    }

    /* Initial HMI state & text: ask user to plug USB
       (must be after widgets are created, so the prompt exists). */
    g_hmi_state = HMI_WAIT_USB;
    hmi_screen_update();

    /* Shows the root window to make it and window1 visible. */
    status = gx_widget_show(p_window_root);
    if (TX_SUCCESS != status)
    {
        while (1);
    }

    /* Lets GUIX run. */
    status = gx_system_start();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

#if defined(BSP_BOARD_S7G2_SK)||defined(BSP_BOARD_S5D9_PK)
    /** Open the SPI driver to initialize the LCD (SK-S7G2) **/
    err = g_spi_lcdc.p_api->open(g_spi_lcdc.p_ctrl, (spi_cfg_t *)g_spi_lcdc.p_cfg);
    if (err)
    {
        while(1);
    }
    /** Setup the ILI9341V (SK-S7G2) **/
    ILI9341V_Init();
#endif

    /* Controls the GPIO pin for LCD ON (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_07_PIN_10, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#elif defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_10_PIN_03, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#endif

    /* Opens PWM driver and controls the TFT panel back light (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK) || defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_pwm_backlight.p_api->open(g_pwm_backlight.p_ctrl, g_pwm_backlight.p_cfg);
    if (err)
    {
        while(1);
    }
#endif

    hmi_state_t previous_state = g_hmi_state;

    while (1)
    {
        ULONG event_flag = 0;

        /* Non-blocking get of touch events */
        status = tx_event_flags_get(&g_touch_event_flags,
                                    UINT32_MAX,
                                    TX_AND_CLEAR,
                                    &event_flag,
                                    TX_NO_WAIT);

        if ((status == TX_SUCCESS) && (event_flag == UINT32_MAX))
        {
            gx_system_event_send(&g_gx_event);
        }

#if 0
        /* Did USB thread change the HMI state? */
        if (previous_state != g_hmi_state)
        {
            hmi_screen_update();     // updates the prompt text
            previous_state = g_hmi_state;
        }
#else
        hmi_screen_update();
#endif

        /* Small sleep so we donâ€™t spin at 100% CPU */
        tx_thread_sleep(1);
    }
}
/**********************************************************************************************************************
 End of function main_thread_entry
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * Function Name: touch_panel_v2_callback
 * Description  : Callback invoked when touch panel event occurs
 * Argument     : p_args
 * Return Value : None
 *********************************************************************************************************************/
void touch_panel_v2_callback(sf_touchpanel_v2_callback_args_t *p_args)
{
    bool send_event = true;
    GX_EVENT * p_gx_event = &g_gx_event;
    sf_touch_panel_v2_payload_t const * const p_payload= &p_args->payload;

    switch (p_payload->event_type)
    {
        /* New touch event reported. */
        case SF_TOUCH_PANEL_V2_EVENT_DOWN:
            p_gx_event->gx_event_type = GX_EVENT_PEN_DOWN;
            break;

        /* Touch released. */
        case SF_TOUCH_PANEL_V2_EVENT_UP:
            p_gx_event->gx_event_type = GX_EVENT_PEN_UP;
            break;

        /* Touch has not moved since last touch event. */
        /* Touch has moved since last touch event. */
        case SF_TOUCH_PANEL_V2_EVENT_HOLD:
        case SF_TOUCH_PANEL_V2_EVENT_MOVE:
            p_gx_event->gx_event_type = GX_EVENT_PEN_DRAG;
            break;


        /* No valid touch event happened. */
        /* Invalid touch data */
        case SF_TOUCH_PANEL_V2_EVENT_NONE:
        case SF_TOUCH_PANEL_V2_EVENT_INVALID:
        default:
            send_event = false;
            break;
    }

    if (send_event)
    {
        /** Send event to GUI */
        p_gx_event->gx_event_sender = GX_ID_NONE;
        p_gx_event->gx_event_target = 0;
        p_gx_event->gx_event_display_handle = 0;

        p_gx_event->gx_event_payload.gx_event_pointdata.gx_point_x = p_payload->x;

#if defined(BSP_BOARD_S7G2_SK)||defined(BSP_BOARD_S5D9_PK)
        p_gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = (GX_VALUE)(320 - p_payload->y);  // SK-S7G2
#else
        p_gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = p_payload->y;  // DK-S7G2, PE-HMI1
#endif

        UINT status = tx_event_flags_set(&g_touch_event_flags, UINT32_MAX, TX_OR);

        /* Confirm that the event flags were set */
        if (TX_SUCCESS != status)
        {
            while (1)
            {
                ;
            }
        }
    }
}
/**********************************************************************************************************************
 End of function touch_panel_v2_callback
 *********************************************************************************************************************/

#if defined(BSP_BOARD_S7G2_SK)||defined(BSP_BOARD_S5D9_PK)
void g_lcd_spi_callback(spi_callback_args_t * p_args)
{
    (void)p_args;
    tx_semaphore_ceiling_put(&g_main_semaphore_lcdc, 1);
}
#endif
