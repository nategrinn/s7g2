#!/usr/bin/env python3
"""
gen_web_assets.py
-----------------
Convert web UI files (HTML/JS/CSS/...) into C byte arrays + a small FileX
provision helper that writes them to a USB stick.

Typical use:
  python gen_web_assets.py -o ./generated -r /www index.html app.html file_manager.js

Outputs (by default):
  web_assets.h
  web_assets.c
  webui_provision.c

Notes:
- This embeds raw bytes (no encoding tricks). Safe for any text/binary file.
- Arrays are const -> they live in Flash/ROM (not RAM) on most embedded toolchains.
"""

import argparse
from pathlib import Path
import re
from typing import List, Tuple

def sanitize_ident(name: str) -> str:
    """Make a valid C identifier fragment."""
    base = re.sub(r'[^0-9A-Za-z]+', '_', name)
    base = base.strip('_')
    if not base:
        base = "ASSET"
    if base[0].isdigit():
        base = "_" + base
    return base.upper()

def bytes_to_c_array(data: bytes, varname: str, cols: int = 12) -> str:
    hexes = [f"0x{b:02X}" for b in data]
    lines = []
    for i in range(0, len(hexes), cols):
        lines.append("    " + ", ".join(hexes[i:i+cols]))
    body = ",\n".join(lines)
    return (
        f"const unsigned char {varname}[] = {{\n{body}\n}};\n"
        f"const unsigned int {varname}_LEN = (unsigned int)sizeof({varname});\n"
    )

def build_assets(file_paths: List[Path], prefix: str) -> Tuple[str, str, List[Tuple[str, str]]]:
    """
    Returns:
      header_text, source_text, symbols[(filename, varname)]
    """
    decls = []
    defs = ['#include "web_assets.h"\n\n']
    symbols: List[Tuple[str, str]] = []

    for p in file_paths:
        data = p.read_bytes()
        var = f"{sanitize_ident(prefix)}_{sanitize_ident(p.name)}"
        decls.append(f"extern const unsigned char {var}[];")
        decls.append(f"extern const unsigned int  {var}_LEN;")
        defs.append(bytes_to_c_array(data, var))
        defs.append("\n")
        symbols.append((p.name, var))

    header = (
        "#pragma once\n"
        "/* Auto-generated by gen_web_assets.py. */\n\n"
        "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n"
        + "\n".join(decls) + "\n\n"
        "#ifdef __cplusplus\n}\n#endif\n"
    )
    source = "".join(defs)
    return header, source, symbols

def build_provision(symbols: List[Tuple[str, str]], root_dir: str, force_overwrite: int) -> str:
    lines = []
    lines.append('#include "fx_api.h"\n#include "web_assets.h"\n')
    lines.append("/* If you want to overwrite existing files on each boot, set to 1. */")
    lines.append("#ifndef WEBUI_FORCE_OVERWRITE")
    lines.append(f"#define WEBUI_FORCE_OVERWRITE ({1 if force_overwrite else 0})")
    lines.append("#endif\n")
    lines.append("/* Change this if your HTTP server serves from a different folder. */")
    lines.append("#ifndef WEBUI_ROOT_DIR")
    lines.append(f'#define WEBUI_ROOT_DIR "{root_dir}"')
    lines.append("#endif\n")

    lines.append("static UINT ensure_dir(FX_MEDIA * media, CHAR * dir_path)\n{")
    lines.append("    UINT st = fx_directory_create(media, dir_path);")
    lines.append("    if (st == FX_ALREADY_CREATED) return FX_SUCCESS;")
    lines.append("    return st;")
    lines.append("}\n")

    lines.append("static UINT file_exists(FX_MEDIA * media, CHAR * path)\n{")
    lines.append("    FX_FILE f;")
    lines.append("    UINT st = fx_file_open(media, &f, path, FX_OPEN_FOR_READ);")
    lines.append("    if (st == FX_SUCCESS) { fx_file_close(&f); return FX_SUCCESS; }")
    lines.append("    return st;")
    lines.append("}\n")

    lines.append("static UINT write_file(FX_MEDIA * media, CHAR * path, const UCHAR * data, ULONG len)\n{")
    lines.append("    FX_FILE f;")
    lines.append("    UINT st;")
    lines.append("    st = fx_file_create(media, path);")
    lines.append("    if ((st != FX_SUCCESS) && (st != FX_ALREADY_CREATED)) return st;")
    lines.append("    st = fx_file_open(media, &f, path, FX_OPEN_FOR_WRITE);")
    lines.append("    if (st != FX_SUCCESS) return st;")
    lines.append("    st = fx_file_truncate(&f, 0);")
    lines.append("    if (st != FX_SUCCESS) { (void)fx_file_close(&f); return st; }")
    lines.append("    st = fx_file_write(&f, (VOID*)data, len);")
    lines.append("    (void)fx_file_close(&f);")
    lines.append("    if (st != FX_SUCCESS) return st;")
    lines.append("    return fx_media_flush(media);")
    lines.append("}\n")

    lines.append("static UINT provision_one(FX_MEDIA * media, CHAR * path, const UCHAR * data, ULONG len)\n{")
    lines.append("#if (WEBUI_FORCE_OVERWRITE == 0)")
    lines.append("    UINT st = file_exists(media, path);")
    lines.append("    if (st == FX_NOT_FOUND) return write_file(media, path, data, len);")
    lines.append("    return (st == FX_SUCCESS) ? FX_SUCCESS : st;")
    lines.append("#else")
    lines.append("    return write_file(media, path, data, len);")
    lines.append("#endif")
    lines.append("}\n")

    lines.append("/* Call once after fx_media_open() succeeds (USB mounted) and before using HTTP server. */")
    lines.append("UINT webui_provision_to_usb(FX_MEDIA * media)\n{")
    lines.append("    UINT st;")
    lines.append("    st = ensure_dir(media, (CHAR*)WEBUI_ROOT_DIR);")
    lines.append("    if (st != FX_SUCCESS) return st;")

    for filename, var in symbols:
        lines.append(f'    st = provision_one(media, (CHAR*)WEBUI_ROOT_DIR "/{filename}", {var}, (ULONG){var}_LEN);')
        lines.append("    if (st != FX_SUCCESS) return st;")

    lines.append("    return FX_SUCCESS;")
    lines.append("}\n")

    return "\n".join(lines)

def main():
    ap = argparse.ArgumentParser(description="Embed web assets as C byte arrays + FileX provision helper.")
    ap.add_argument("files", nargs="+", help="Input files (e.g., index.html app.html file_manager.js)")
    ap.add_argument("-o", "--out-dir", default=".", help="Output directory (default: .)")
    ap.add_argument("-p", "--prefix", default="WEB", help="Prefix for C symbols (default: WEB)")
    ap.add_argument("-r", "--root-dir", default="/www", help='Target dir on USB (default: "/www")')
    ap.add_argument("--force-overwrite", action="store_true", help="Overwrite existing files every boot (default: off)")
    ap.add_argument("--h-name", default="web_assets.h", help="Header filename (default: web_assets.h)")
    ap.add_argument("--c-name", default="web_assets.c", help="Source filename (default: web_assets.c)")
    ap.add_argument("--prov-name", default="webui_provision.c", help="Provision helper filename (default: webui_provision.c)")
    args = ap.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    file_paths = [Path(f) for f in args.files]
    for p in file_paths:
        if not p.exists():
            raise SystemExit(f"Input file not found: {p}")

    h_text, c_text, symbols = build_assets(file_paths, args.prefix)
    prov_text = build_provision(symbols, args.root_dir, 1 if args.force_overwrite else 0)

    (out_dir / args.h_name).write_text(h_text, encoding="utf-8", newline="\n")
    (out_dir / args.c_name).write_text(c_text, encoding="utf-8", newline="\n")
    (out_dir / args.prov_name).write_text(prov_text, encoding="utf-8", newline="\n")

    print("Generated:")
    print(" -", out_dir / args.h_name)
    print(" -", out_dir / args.c_name)
    print(" -", out_dir / args.prov_name)

if __name__ == "__main__":
    main()
